import tensorflow as tf
from tensorflow.keras import losses
from CONSTANTS import NUM_CLASSES, BATCH_SIZE


class CustomSSDLoss(losses.Loss):
    def __init__(self,grid, ratio = 3.0, alpha = 1.0,name="CustomSSDLoss"):
        '''
        Parameters:
            grid (tf tensor) : For every box generated by the model,
                there is a list of offsets that are added to it.

                ie, for every box, we add a Center X and Center Y offset
                as well as a pre determines width and height according to
                the scale

                the grid is of the form [BATCH_SIZE, NUM_BOXES_PER_IMAGE, \
                    [c1,c2,c3...,cn, Cx, Cy, w, h ]] where c1,c2 are class 1,
                    class 2 confidences

            Calculates loss according to : https://arxiv.org/pdf/1512.02325.pdf
        '''
        super().__init__(name=name)
        self.grid = grid
        self.ratio = ratio
        self.alpha = alpha
        self.name = name

    def call(self, y_true, y_pred):
        # calculate jacard overlap
        x_min_grid = self.grid[:,:,11] - tf.divide(self.grid[:,:,13],2.0)
        x_max_grid = self.grid[:,:,11] + tf.divide(self.grid[:,:,13],2.0)
        y_min_grid = self.grid[:,:,12] - tf.divide(self.grid[:,:,14],2.0)
        y_max_grid = self.grid[:,:,12] + tf.divide(self.grid[:,:,14],2.0)

        
        x_min_gt = y_true[:,11] - tf.divide(y_true[:,13],2.0)
        x_max_gt = y_true[:,11] + tf.divide(y_true[:,13],2.0)
        y_min_gt = y_true[:,12] - tf.divide(y_true[:,14],2.0)
        y_max_gt = y_true[:,12] + tf.divide(y_true[:,14],2.0)

        x_min_gt_expand = tf.tile(\
            tf.expand_dims(x_min_gt,axis=1),[1,self.grid.shape[1]])
        y_min_gt_expand = tf.tile(\
            tf.expand_dims(y_min_gt,axis=1),[1,self.grid.shape[1]])
        x_max_gt_expand = tf.tile(\
            tf.expand_dims(x_max_gt,axis=1),[1,self.grid.shape[1]])
        y_max_gt_expand = tf.tile(\
            tf.expand_dims(y_max_gt,axis=1),[1,self.grid.shape[1]])

        x_a = tf.maximum(x_min_gt_expand,x_min_grid)
        y_a = tf.maximum(y_min_gt_expand,y_min_grid)
        x_b = tf.minimum(x_max_gt_expand,x_max_grid)
        y_b = tf.minimum(y_max_gt_expand,y_max_grid)

        inter_area = tf.maximum(0.0,x_b-x_a) * tf.maximum(0.0, y_b - y_a)

        boxAArea = (x_max_gt_expand-x_min_gt_expand)*\
            (y_max_gt_expand-y_min_gt_expand)
        boxBArea = (x_max_grid-x_min_grid)*\
            (y_max_grid-y_min_grid)

        overlap = inter_area / (boxAArea+boxBArea-inter_area)

        # find boxes loss
        g_cx = ( tf.tile(tf.expand_dims(y_true[:,11],axis=1), \
            [1,self.grid.shape[1]]) - self.grid[:,:,11] ) / self.grid[:,:,13]

        g_cy = ( tf.tile(tf.expand_dims(y_true[:,12],axis=1), \
            [1,self.grid.shape[1]]) - self.grid[:,:,12] ) / self.grid[:,:,14]

        g_w = tf.math.log(tf.tile(tf.expand_dims(y_true[:,13],axis=1), \
            [1,self.grid.shape[1]]) / self.grid[:,:,13])

        g_h = tf.math.log(tf.tile(tf.expand_dims(y_true[:,14],axis=1), \
            [1,self.grid.shape[1]])/ self.grid[:,:,14])


        g_cx = tf.expand_dims(g_cx,axis=2)
        g_cy = tf.expand_dims(g_cy,axis=2)
        g_w = tf.expand_dims(g_w,axis=2)
        g_h = tf.expand_dims(g_h,axis=2)

        box_gt = tf.concat([g_cx, g_cy, g_w, g_h],axis=2)
        box_pr = y_pred[:,:,-4:]

        smooth_l1 = tf.keras.losses.Huber(delta=1.0, reduction = tf.keras.\
            losses.Reduction.NONE, name='huber_loss')

        box_loss = smooth_l1(box_gt,box_pr)
        
        # find class loss
        #   for masking
        y_true_labels = y_true[:,:11]        
        y_true_labels = tf.tile(tf.expand_dims(y_true[:,:11],axis=1), \
            [1,self.grid.shape[1],1]) 

        y_pred_labels = y_pred[:,:,:11]
        softmx_scores = tf.nn.softmax(y_pred_labels)

        pos_match_idx = overlap>0.5
        pos_box_mask  = tf.cast(pos_match_idx,tf.float32)

        # find loss for matched boxes and unmatched boxes
        positive_softmax_loss = -(softmx_scores*y_true_labels)
        # sum of softmax score per box
        positive_softmax_loss_reduced = tf.reduce_sum(\
            positive_softmax_loss,axis=2)

        neg_match_idx = tf.logical_not(pos_match_idx)
        neg_match_mask = tf.cast(neg_match_idx,tf.float32)
        
        # softmax score of negative class per box
        negative_softmax_loss_reduced = \
            (softmx_scores[:,:,10]*neg_match_mask)

        num_pos = tf.reduce_sum(pos_box_mask,axis=1)

        average_num_pos_boxes = tf.cast(tf.reduce_mean(num_pos),tf.int32)

        # calculate the average number of positive matched boxes,
        # find the average number of negative boxes 
        average_num_neg_boxes = tf.cast(\
            average_num_pos_boxes,tf.float32)*self.ratio
        average_num_neg_boxes = tf.cast(average_num_neg_boxes,tf.int32)

        # calculating negative mined top k from average pos boxes
        neg_softmax_hard_mined_boxes, _idxs = \
            tf.math.top_k(negative_softmax_loss_reduced, \
                k=average_num_neg_boxes )
        

        # return sums
        final_pos_softmax_loss = tf.reduce_sum(\
            positive_softmax_loss_reduced*pos_box_mask, axis=1)

        final_neg_softmax_loss = tf.reduce_sum(\
            -neg_softmax_hard_mined_boxes, axis=1)

        final_pos_localisation_loss = tf.reduce_sum(\
            box_loss*pos_box_mask, axis = 1)

        ssd_loss = final_pos_softmax_loss + final_neg_softmax_loss + \
            (self.alpha*final_pos_localisation_loss)

        greater_than_zero_boxes_mask = tf.cast(num_pos>0,tf.int32)

        ssd_loss_div = (ssd_loss/(num_pos+1))* \
            tf.cast(greater_than_zero_boxes_mask,tf.float32)

        ssd_loss_reduced = tf.reduce_sum(ssd_loss_div)

        return ssd_loss_reduced


class CustomSSDLossCrossEntropy(losses.Loss):
    def __init__(self,grid, ratio = 3.0, alpha = 10.0,\
        name="CustomSSDCrossEntropyLoss"):
        '''
        Parameters:
            grid (tf tensor) : For every box generated by the model,
                there is a list of offsets that are added to it.

                ie, for every box, we add a Center X and Center Y offset
                as well as a pre determines width and height according to
                the scale

                the grid is of the form [BATCH_SIZE, NUM_BOXES_PER_IMAGE, \
                    [c1,c2,c3...,cn, Cx, Cy, w, h ]] where c1,c2 are class 1,
                    class 2 confidences

            Calculates loss according to : https://arxiv.org/pdf/1512.02325.pdf
        '''
        super().__init__(name=name)
        self.grid = grid
        self.ratio = ratio
        self.alpha = alpha
        self.name = name


    def call(self, y_true, y_pred):

        # calculate jacard overlap
        x_min_grid = self.grid[:,:,11] - tf.divide(self.grid[:,:,13],2.0)
        x_max_grid = self.grid[:,:,11] + tf.divide(self.grid[:,:,13],2.0)
        y_min_grid = self.grid[:,:,12] - tf.divide(self.grid[:,:,14],2.0)
        y_max_grid = self.grid[:,:,12] + tf.divide(self.grid[:,:,14],2.0)

        
        x_min_gt = y_true[:,11] - tf.divide(y_true[:,13],2.0)
        x_max_gt = y_true[:,11] + tf.divide(y_true[:,13],2.0)
        y_min_gt = y_true[:,12] - tf.divide(y_true[:,14],2.0)
        y_max_gt = y_true[:,12] + tf.divide(y_true[:,14],2.0)

        x_min_gt_expand = tf.tile(\
            tf.expand_dims(x_min_gt,axis=1),[1,self.grid.shape[1]])
        y_min_gt_expand = tf.tile(\
            tf.expand_dims(y_min_gt,axis=1),[1,self.grid.shape[1]])
        x_max_gt_expand = tf.tile(\
            tf.expand_dims(x_max_gt,axis=1),[1,self.grid.shape[1]])
        y_max_gt_expand = tf.tile(\
            tf.expand_dims(y_max_gt,axis=1),[1,self.grid.shape[1]])

        x_a = tf.maximum(x_min_gt_expand,x_min_grid)
        y_a = tf.maximum(y_min_gt_expand,y_min_grid)
        x_b = tf.minimum(x_max_gt_expand,x_max_grid)
        y_b = tf.minimum(y_max_gt_expand,y_max_grid)

        inter_area = tf.maximum(0.0,x_b-x_a) * tf.maximum(0.0, y_b - y_a)

        boxAArea = (x_max_gt_expand-x_min_gt_expand)*\
            (y_max_gt_expand-y_min_gt_expand)
        boxBArea = (x_max_grid-x_min_grid)*\
            (y_max_grid-y_min_grid)

        overlap = inter_area / (boxAArea+boxBArea-inter_area)

        # find boxes loss
        g_cx = ( tf.tile(tf.expand_dims(y_true[:,11],axis=1), \
            [1,self.grid.shape[1]]) - self.grid[:,:,11] ) / self.grid[:,:,13]

        g_cy = ( tf.tile(tf.expand_dims(y_true[:,12],axis=1), \
            [1,self.grid.shape[1]]) - self.grid[:,:,12] ) / self.grid[:,:,14]

        g_w = tf.math.log(tf.tile(tf.expand_dims(y_true[:,13],axis=1), \
            [1,self.grid.shape[1]]) / self.grid[:,:,13])

        g_h = tf.math.log(tf.tile(tf.expand_dims(y_true[:,14],axis=1), \
            [1,self.grid.shape[1]]) / self.grid[:,:,14])


        g_cx = tf.expand_dims(g_cx,axis=2)
        g_cy = tf.expand_dims(g_cy,axis=2)
        g_w = tf.expand_dims(g_w,axis=2)
        g_h = tf.expand_dims(g_h,axis=2)

        box_gt = tf.concat([g_cx, g_cy, g_w, g_h],axis=2)
        box_pr = y_pred[:,:,-4:]

        # smooth_l1 = tf.keras.losses.Huber(delta=30.0, \
        #     reduction = tf.keras.losses.Reduction.NONE, name='huber_loss')

        # box_loss = smooth_l1(box_gt,box_pr)
        box_loss = tf.reduce_sum(tf.abs(box_gt-box_pr),axis=2)

        pos_match_idx = overlap>0.5
        pos_box_mask  = tf.cast(pos_match_idx,tf.float32)
        
        # # find class loss
        # #   for masking
        y_true_labels = y_true[:,:11]        
        y_true_labels = tf.tile(tf.expand_dims(y_true[:,:11],axis=1), \
            [1,self.grid.shape[1],1])
        y_neg_labels = tf.concat([tf.zeros([NUM_CLASSES]),[1]],axis=0)
        y_neg_labels = tf.expand_dims(y_neg_labels,axis=0)
        y_neg_labels = tf.expand_dims(y_neg_labels,axis=0)
        
        y_neg_labels = tf.tile(y_neg_labels, \
            [1, y_true_labels.shape[1],1])

        neg_box_mask = 1 - pos_box_mask

        elemwise_pos_mask = tf.tile(tf.expand_dims(pos_box_mask,axis=2),[1,1,11])
        elemwise_neg_mask = tf.tile(tf.expand_dims(neg_box_mask,axis=2),[1,1,11])

        pos_neg_labels = y_true_labels*elemwise_pos_mask + \
            y_neg_labels*elemwise_neg_mask

        cross_entropy = tf.keras.losses.CategoricalCrossentropy(\
            from_logits=True,reduction=tf.keras.losses.Reduction.NONE)

        softmx_scores = cross_entropy(pos_neg_labels,y_pred[:,:,:11])

        # find loss for matched boxes and neg matched boxes
        positive_softmax_loss = softmx_scores*pos_box_mask

        num_pos = tf.reduce_sum(pos_box_mask,axis=1)
        average_num_pos_boxes = tf.reduce_mean(num_pos)
        average_num_neg_boxes = average_num_pos_boxes * self.ratio

        negative_softmax_loss, _idxs = tf.math.top_k( \
            softmx_scores*(1-pos_box_mask), \
            k=tf.cast(average_num_neg_boxes,tf.int32))

        # sum of softmax score per box
        positive_softmax_loss_reduced = tf.reduce_sum( \
            positive_softmax_loss,axis=1)

        negative_softmax_loss_reduced = tf.reduce_sum( \
            negative_softmax_loss,axis=1)

        final_pos_localisation_loss = tf.reduce_sum(\
            box_loss*pos_box_mask, axis = 1)

        ssd_loss = (self.ratio*positive_softmax_loss_reduced) + \
            negative_softmax_loss_reduced + \
            (self.alpha * final_pos_localisation_loss)
        
        greater_than_zero_boxes_mask = tf.cast(num_pos>0,tf.int32)

        ssd_loss_div = (ssd_loss/(num_pos+1))* \
            tf.cast(greater_than_zero_boxes_mask,tf.float32)

        ssd_loss_reduced = tf.reduce_sum(ssd_loss_div)

        return ssd_loss_reduced